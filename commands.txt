db.help()

DB methods:
        db.adminCommand(nameOrDocument) - switches to 'admin' db, and runs command [just calls db.runCommand(...)]      
        db.aggregate([pipeline], {options}) - performs a collectionless aggregation on this database; returns a cursor  
        db.auth(username, password)
        db.cloneDatabase(fromhost) - will only function with MongoDB 4.0 and below
        db.commandHelp(name) returns the help for the command
        db.copyDatabase(fromdb, todb, fromhost) - will only function with MongoDB 4.0 and below
        db.createCollection(name, {size: ..., capped: ..., max: ...})
        db.createUser(userDocument)
        db.createView(name, viewOn, [{$operator: {...}}, ...], {viewOptions})
        db.currentOp() displays currently executing operations in the db
        db.dropDatabase(writeConcern)
        db.dropUser(username)
        db.eval() - deprecated
        db.fsyncLock() flush data to disk and lock server for backups
        db.fsyncUnlock() unlocks server following a db.fsyncLock()
        db.getCollection(cname) same as db['cname'] or db.cname
        db.getCollectionInfos([filter]) - returns a list that contains the names and options of the db's collections    
        db.getCollectionNames()
        db.getLastError() - just returns the err msg string 
        db.getLastErrorObj() - return full status object    
        db.getLogComponents()
        db.getMongo() get the server connection object      
        db.getMongo().setSlaveOk() allow queries on a replication slave server
        db.getName()
        db.getProfilingLevel() - deprecated
        db.getProfilingStatus() - returns if profiling is on and slow threshold
        db.getReplicationInfo()
        db.getSiblingDB(name) get the db at the same server as this one
        db.getWriteConcern() - returns the write concern used for any operations on this db, inherited from server object if set
        db.hostInfo() get details about the server's host   
        db.isMaster() check replica primary status
        db.killOp(opid) kills the current operation in the d> db.help()
DB methods:
        db.adminCommand(nameOrDocument) - switches to 'admin' db, and runs command [just calls db.runCommand(...)]      
        db.aggregate([pipeline], {options}) - performs a collectionless aggregation on this database; returns a cursor  
        db.auth(username, password)
        db.cloneDatabase(fromhost) - will only function with MongoDB 4.0 and below
        db.commandHelp(name) returns the help for the command
        db.copyDatabase(fromdb, todb, fromhost) - will only function with MongoDB 4.0 and below
        db.createCollection(name, {size: ..., capped: ..., max: ...})
        db.createUser(userDocument)
        db.createView(name, viewOn, [{$operator: {...}}, ...], {viewOptions})
        db.currentOp() displays currently executing operations in the db
        db.dropDatabase(writeConcern)
        db.dropUser(username)
        db.eval() - deprecated
        db.fsyncLock() flush data to disk and lock server for backups
        db.fsyncUnlock() unlocks server following a db.fsyncLock()
        db.getCollection(cname) same as db['cname'] or db.cname
        db.getCollectionInfos([filter]) - returns a list that contains the names and options of the db's collections    
        db.getCollectionNames()
        db.getLastError() - just returns the err msg string 
        db.getLastErrorObj() - return full status object    
        db.getLogComponents()
        db.getMongo() get the server connection object      
        db.getMongo().setSlaveOk() allow queries on a replication slave server
        db.getName()
        db.getProfilingLevel() - deprecated
        db.getProfilingStatus() - returns if profiling is on and slow threshold
        db.getReplicationInfo()
        db.getSiblingDB(name) get the db at the same server as this one
        db.getWriteConcern() - returns the write concern used for any operations on this db, inherited from server object if set
        db.hostInfo() get details about the server's host   
        db.isMaster() check replica primary status
        db.killOp(opid) kills the current operation in the db
        db.listCommands() lists all the db commands
        db.loadServerScripts() loads all the scripts in db.system.js
        db.logout()
        db.printCollectionStats()
        db.printReplicationInfo()
        db.printShardingStatus()
        db.printSlaveReplicationInfo()
        db.resetError()
        db.runCommand(cmdObj) run a database command.  if cmdObj is a string, turns it into {cmdObj: 1}
        db.serverStatus()
        db.setLogLevel(level,<component>)
        db.setProfilingLevel(level,slowms) 0=off 1=slow 2=all
        db.setVerboseShell(flag) display extra information in shell output
        db.setWriteConcern(<write concern doc>) - sets the write concern for writes to the db
        db.shutdownServer()
        db.stats()
        db.unsetWriteConcern(<write concern doc>) - unsets the write concern for writes to the db
        db.version() current version of the server
        db.watch() - opens a change stream cursor for a database to report on all  changes to its non-system collections.


> show dbs      
admin    0.000GB
config   0.000GB
> db.createCollection('Students')
{ "ok" : 1 }
> db.createCollection('Customers')
{ "ok" : 1 }
> show collections
Customers
Students
> show dbs      
admin    0.000GB
config   0.000GB
ishdb    0.000GB
local    0.000GB



#   to create a database
-------------------------
> use ishdb
switched to db ishdb

#   to create collections
--------------------------
> db.createCollection("employees")
{ "ok" : 1 }

> show dbs      
admin    0.000GB
config   0.000GB
ishdb    0.000GB
local    0.000GB


# to show collections
---------------------
> show collections
employees

# to drop collection
---------------------

db.collectionname.drop()

> show collections  
employees
> db.employees.drop()
true
> show collections   
> show dbs     -> ishdb not show coz dbalteast one collection is required in db    
admin    0.000GB
config   0.000GB
local    0.000GB


> db.createCollection('Students')
{ "ok" : 1 }
> db.createCollection('Customers')
{ "ok" : 1 }

> show collections
Customers
Students

> show dbs      
admin    0.000GB
config   0.000GB
ishdb    0.000GB
local    0.000GB


> db.createCollection('Students')
{ "ok" : 1 }
> db.createCollection('Customers')
{ "ok" : 1 }

> show collections
Customers
Students

> show dbs      
admin    0.000GB
config   0.000GB
ishdb    0.000GB
local    0.000GB


#   Basic CRUD Operations:
--------------------------

1. C ----> Creation:  to insert document into collection

db.collection.insertOne()
db.collection.insertMany()
db.collection.insert()

ex: 
> db.Employees.insertOne({eno:101, ename:"Ravi", esal:10000,eaddress:"Delhi"}) 
{
        "acknowledged" : true,
        "insertedId" : ObjectId("608d311fb7b5bc4b7c433a1e")
}
>

2. R  ---> Retrieval/Read
--------------------------
db.collection.find()        ---> return all documents
db.collection.findOne()     ---> return one document only

ex:
> db.Employees.find()
{ "_id" : ObjectId("608d31d9b7b5bc4b7c433a20"), "eno" : 101, "ename" : "Ravi", "esal" : 10000, "eaddress" : "Delhi" }   
{ "_id" : ObjectId("608d3417b7b5bc4b7c433a21"), "eno" : 102, "ename" : "Raman", "esal" : 12000, "eaddress" : "Jaipur" } 
{ "_id" : ObjectId("608d342eb7b5bc4b7c433a22"), "eno" : 103, "ename" : "Ram", "esal" : 15000, "eaddress" : "Jammu" }    
{ "_id" : ObjectId("608d3442b7b5bc4b7c433a23"), "eno" : 103, "ename" : "Ramesh", "esal" : 11000, "eaddress" : "Delhi" } 
>

> db.Employees.find().pretty()   ---> return documents in readable format
{
        "_id" : ObjectId("608d31d9b7b5bc4b7c433a20"),
        "eno" : 101,
        "ename" : "Ravi",
        "esal" : 10000,
        "eaddress" : "Delhi"
}
{
        "_id" : ObjectId("608d3417b7b5bc4b7c433a21"),
        "eno" : 102,
        "ename" : "Raman",
        "esal" : 12000,
        "eaddress" : "Jaipur"
}
{
        "_id" : ObjectId("608d342eb7b5bc4b7c433a22"),       
        "eno" : 103,
        "ename" : "Ram",
        "esal" : 15000,
        "eaddress" : "Jammu"
}
{
        "_id" : ObjectId("608d3442b7b5bc4b7c433a23"),       
        "eno" : 103,
        "ename" : "Ramesh",
        "esal" : 11000,
        "eaddress" : "Delhi"
}
>

3. U ---> Update: to update document
------------------------------------

db.collection.updateOne()
db.collection.updateMany()
db.collection.replaceOne()

> db.Employees.updateOne({ename: "Ram"}, {$set: {esal:15500}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
>

4. D ---> Delete: to delete document
------------------------------------

db.collection.deleteOne()
db.collection.deleteMany()

> db.Employees.deleteOne({ename: "Ram"})
{ "acknowledged" : true, "deletedCount" : 1 }
>


## It is not required to create collections explicitly. Whenever we are trying to insert documents, collections will be automatically created.

ex: 
> use testDB
switched to db testDB
> db.Employees.insertOne({eno:103, ename:"Ram", esal:15500,eaddress:"Noida"})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("608d3b54b7b5bc4b7c433a25")
}

> show collections
Employees
> db.Employees.find()
{ "_id" : ObjectId("608d3b54b7b5bc4b7c433a25"), "eno" : 103, "ename" : "Ram", "esal" : 15500, "eaddress" : "Noida" }    
>


## Capped collections

db.createCollection(name) -> this will create a normal document

one use case:
        max 1000 documents --> 1001 documents
        size : 3736578 bytes only --> if space completed

But whenever we have some requirements to put restriction on max no. of documents or size of collection then we need to use capped collections.
ex: capped
        max 1000 documents
        size : size allocated to the collection

db.createCollection(name, options)

db.createCollection("name", {capped: true, size: size in bytes, max: no. of documents})

        old document will be delete automatically based on time stamp.

If capped is true means that if size exceeds or maximum number of documents reached, then oldest
entry will be deleted automatically.

1. db.createCollection("name") --> Normal collection
2. db.createCollection("name", {capped: true}) --> Invalid collection
        ex: > db.createCollection("testCollection",{capped:true})
        {
                "ok" : 0,
                "errmsg" : "the 'size' field is required when 'capped' is true",
                "code" : 72,
                "codeName" : "InvalidOptions"
        }
        > 


3. db.createCollection("testCollection", {capped: true, size: 365675})  --> Valid collection
{ "ok" : 1 }
> show collections
Customer
Employees
Students
testCollection    
>

4. db.createCollection("testCollection1", {size: 365675})  ---> Invalid collection
{
        "ok" : 0,
        "errmsg" : "the 'capped' field needs to be true when either the 'size' or 'max' fields are present",
        "code" : 72,
        "codeName" : "InvalidOptions"
}
>

5. db.createCollection("testCollection2", {capped: true, size: 365675, max: 1000})  ---> Valid collection
        { "ok" : 1 }
> show collections
Customer
Employees
Students
testCollection    
testCollection2   
>

6. db.createCollection("testCollection1", {capped: true, size: 365675, max: 1})

ex: db.testCollection1.insertOne({id: 1001, ename:"Rishi"})  
        {
                "acknowledged" : true,
                "insertedId" : ObjectId("609222a31e6d7e120a44fd28")
        }
        
        > db.testCollection1.find()
        { "_id" : ObjectId("609222a31e6d7e120a44fd28"), "id" : 1001, "ename" : "Rishi" }
        

        > db.testCollection1.insertOne({id: 1002, ename:"Rishima"})
        {
                "acknowledged" : true,
                "insertedId" : ObjectId("609222d61e6d7e120a44fd29")
        }
        > db.testCollection1.find()
        { "_id" : ObjectId("609222d61e6d7e120a44fd29"), "id" : 1002, "ename" : "Rishima" }
        >



use case:
---------
fresher jobs portal ---> students registered
        students collection --> 1 lakh entires
        job collection --> 100 jobs available





